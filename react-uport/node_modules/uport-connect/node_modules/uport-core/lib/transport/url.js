'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onResponse = exports.listenResponse = exports.getResponse = exports.send = undefined;

var _util = require('./../message/util.js');

var _qs = require('qs');

var _qs2 = _interopRequireDefault(_qs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO Could have separate func for signed payloads (below)
// TODO id and data or one field here with two in connect
// TODO callback_url and redirect or just one
// TODO details docs or give reference to specs
/**
  *  A mobile transport for handling and configuring requests which are sent from a mobile browser to a uport client, in this case the uPort mobile app.
  *
  *  @param    {Object}       [config={}]    an optional config object
  *  @param    {String}       uriHandler     a function called with the requestURI once it is formatted for this transport, default opens URI
  *  @return   {Function}                    a configured MobileTransport Function
  *  @param    {String}       uri            a uport client request URI
  *  @param    {Object}       [opts={}]      an optional config object
  *  @param    {String}       opts.id        an id string for a request, used to identify response once returned
  *  @param    {String}       opts.data      additional data specific to your application that you can later receive with the response
  *  @param    {String}       opts.type      specifies callback type 'post' or 'redirect' for response
  *  @param    {String}       opts.callback  specifies url which a uport client will return to control once request is handled, depending on request type it may or may not be returned with the response as well.
  */
var send = function send() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      uriHandler = _ref.uriHandler;

  // TODO args below or above? extra details above
  return function (uri) {
    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        id = _ref2.id,
        data = _ref2.data,
        type = _ref2.type,
        callback = _ref2.callback;

    // what if has no protocol in passed in string
    // if( md.userAgent() === 'Chrome' && md.os() === 'iOS' ) {
    //    url = 'googlechrome:' + window.location.href.substring(window.location.protocol.length)
    //  } else {
    //    url = window.location.href
    //  }
    if (type) uri = (0, _util.paramsToQueryString)(uri, { type: type });
    // Maybe move this logic (line) up a level to connect?
    var cb = /requestToken/.test(uri) ? callback || null : callback || window.location.href;
    if (cb) {
      if (data) cb = (0, _util.paramsToUrlFragment)(cb, { data: data });
      if (id) cb = (0, _util.paramsToUrlFragment)(cb, { id: id });
      uri = /requestToken/.test(uri) ? (0, _util.paramsToQueryString)(uri, { 'redirect_url': cb }) : (0, _util.paramsToQueryString)(uri, { 'callback_url': cb });
    }
    uriHandler ? uriHandler(uri) : window.location.assign(uri);
  };
};

/**
  *  A function to fetch a response from hash params appended to callback url, if available when function called.
  *
  *  @return   {Object}   A response object if repsonse is available, otherwise null.
  */
var getResponse = function getResponse() {
  if (!!window.location.hash) {
    // TODO remove redundant
    var params = _qs2.default.parse(window.location.hash.slice(1));
    window.location.hash = '';
    if (params.error) return { error: params.error };
    return { res: params['access_token'], data: params['data'], id: params['id'] };
  }
  return null;
};

// TODO should there be a way to cancel
/**
  *  A listener which calls given callback when a response becomes avaialble in the hash params (url fragment)
  *
  *  @param    {Function}     cb     a callback function called as cb(err, res) when a response becomes available
  */
var listenResponse = function listenResponse(cb) {
  window.onhashchange = function () {
    var res = getResponse();
    if (res) res.error ? cb(res.error, null) : cb(null, res);
  };
};

/**
  *  A promise which resolves once a response become available in the hash params (url fragment)
  *
  *  @return   {Promise<Object, Error>}    a promise which resolves with a response object or rejects with an error.
  */
var onResponse = function onResponse() {
  return new Promise(function (resolve, reject) {
    listenResponse(function (err, res) {
      err ? reject(err) : resolve(res);
    });
  });
};

exports.send = send;
exports.getResponse = getResponse;
exports.listenResponse = listenResponse;
exports.onResponse = onResponse;